%Реализовать предикат sum_list_down(+List, ?Summ), который
%проверяет, является ли Summ суммой элементов списка или записывает в эту
%переменную сумму элементов. Для построения воспользоваться рекурсией
%вниз. Реализовать программу, читающую список, считающую сумму
%элементов и выводящую сумму на экран, с использованием предикатов из
%задания 1 и построенного предиката sum_list_down /2.

sum_list_down([],ST,Summ):-Summ is ST.
sum_list_down([H|T],ST,Summ):-sum_list_down(T,ST+H,Summ).
sum_list_down([H|T],Summ):-sum_list_down([H|T],0,Summ).

%Построить предикат sum_list_up(+List, ?Summ), который
%проверяет, является ли Summ суммой элементов списка или записывает в эту
%переменную сумму элементов. Для построения воспользоваться рекурсией
%вверх.

sum_list_up([],Summ):-Summ is 0.
sum_list_up([H|T],Summ):-sum_list_up(T,ST),Summ is H + ST.

%Построить предикат, list_el_numb(+List, ?Elem, ?Number).
%Если задано значение Elem, то предикат записывает в Number номер первого
%вхождения Elem. Если задано значение Number, то предикат записывает в Elem
%значение, находящееся в списке под номером Number. Если заданы оба
%значения, то предикат проверяет, находится ли элемент Elem в списке под
%номером Numb.

%list_el_numb([E,_],E,TN,N):-N is TN,!.
%list_el_numb([H,_],E,N,N):-E is H,!.

list_el_numb([H|_],H,N,N):-!.
list_el_numb([_|T],E,TN,N):-TNN is TN+1, list_el_numb(T,E,TNN,N).
list_el_numb([H|T],E,N):-list_el_numb([H|T],E,0,N).

%Реализовать программу, которая читает список, читает
%элемент и находит номер первого вхождения элемента в список. В случае, если
%элемент отсутствует, пользователю выводится соответствующее сообщение.
%Воспользоваться предикатами из заданий 1 и 3.

first_in([H|_],H,N):-N is 1,!.
first_in([_|T],E,N):-first_in(T,E,NT),N is NT+1.

%Задание 5. Реализовать программу, которая читает список, читает номер
%элемента и находит соответствующий элемент. В случае, если номер
%некорректный, пользователю выводится соответствующее сообщение.

el([H|_],0,H):-!.
el([_|T],N,E):-NT is N-1, el(T,NT,E).

%Задание 6. Реализовать предикат min_list_up(+List, ?Min), который
%записывает минимальный элемент списка List в переменную Min или
%проверяет, является ли значение в переменной Min минимальным элементом
%в списке List. Реализацию провести рекурсией вверх.

min_list_up([H],M):-M is H,!.
min_list_up([H|T],M):-min_list_up(T,MT), ((H<MT)->(M is H); (M is MT)).

%Задание 7. Реализовать предикат min_list_down(+List, ?Min), который
%записывает минимальный элемент списка List в переменную Min или
%проверяет, является ли значение в переменной Min минимальным элементом
%в списке List. Реализацию провести рекурсией вниз.

min_list_down([],M,M):-!.
min_list_down([H|T],MT,M):-(H<MT)->(min_list_down(T,H,M));(min_list_down(T,MT,M)).
min_list_down([H|T],M):-min_list_down([H|T],H,M).

%Задание 8. Реализовать программу, которая читает список, находит и
%выводит на экран его минимальный элемент. Воспользоваться предикатами из
%заданий 1, 6 или 7.

%min_list_down([],M,M):-!.
%min_list_down([H|T],MT,M):-(H<MT)->(min_list_down(T,H,M));(min_list_down(T,MT,M)).
%min_list_down([H|T],M):-min_list_down([H|T],H,M).

%Задание 9. Построить предикат, который возвращает true, если элемент
%есть в списке.

contains([H|_],H):-!.
contains([_|T],E):-contains(T,E).
%Задание 10. Построить предикат, который переворачивает список.
poplast([H|[L]],[H],L):-!.
poplast([H|T],[H|NT],L):-poplast(T,NT,L).

reverse([H],[H]):-!.
reverse([H|T],[HN|TN]):-poplast([H|T],[HT|TT],HN), reverse([HT|TT],TN).
%Задание 11. Построить предикат p(Sublist,List), который возвращает true,
%если элементы Sublist встречается в List в том же порядке.
%p([],_):-!.
%p(ST,[H|T]):-(SH=:=H)->(p(ST,T));(p(ST,T)).
p([],_):-!.
p([SH|ST],[H|T]):-SH=:=H->p(ST,T);p([SH|ST],T).
%Задание 12. Построить предикат, который удаляет элемент с заданным
%номером из списка.
del([_,H2|T],1,[H2|T]):-!.
del([_|_],1,[]):-!.
del([H|T],N,[H|TN]):-NN is N-1, del(T,NN,TN).

%Задание 13. Построить предикат, который удаляет все элементы, равные
%данному.
deleq([],_,[]):-!.
deleq([E|T],E,[H|TN]):-deleq(T,E,[H|TN]).
deleq([H|T],E,[H|TN]):-deleq(T,E,TN).

%Содержит ли список число
is_contains([],_):-false.
is_contains([H|T],X):-H=:=X -> true; is_contains(T,X).

%Добавление элемента в конец
add([],E,[E]).
add([H|T],E,[H|T1]):-add(T,E,T1).

%Задание 15. Построить предикат, который строит новый список,
%составленный из уникальных элементов введенного, то есть убирает все
%повторы, например из списка [1,1,2,3,3,3] получает список [1,2,3].
set([],[H|T],[H|T]).
set([H|T],[HT|TT],TR):-(is_contains([HT|TT],H)) -> (set(T,[HT|TT],TR)); (add([HT|TT],H,[HTT|TTT]),set(T,[HTT|TTT],TR)).
set([H|T],TR):-set([H|T],[H],TR).

%Задание 16. Построить предикат, который получает для данного
%элемента количество раз, которое он встречается в списке.
contain_num([],_,NT,N):-N is NT.
contain_num([H|T],X,NT,N):-X=:=H -> contain_num(T,X,NT+1,N); contain_num(T,X,NT,N).
contain_num([H|T],X,N):-contain_num([H|T],X,0,N).

%Задание 14. Построить предикат, который проверяет, встречаются ли все
%элементы в списке ровно 1 раз.
%Сколько раз элемент списка L1 с таким номером повторяется в исходном
cn_list(_,[],[HT|TT],[HT|TT]):-!.
cn_list([H|T],[HS|TS],[HT|TT],TR):-contain_num([H|T],HS,N), add([HT|TT],N,[HTT|TTT]), cn_list([H|T],TS,[HTT|TTT],TR).
cn_list([H|T],TR):-set([H|T],[HS|TS]), contain_num([H|T],HS,N), cn_list([H|T],TS,[N],TR).

%Единичный ли список
eq1([]):-!.
eq1([1|T]):-eq1(T).

just1(L):-cn_list(L,NL),eq1(NL).
%Задание 17. Построить предикат, получающий длину списка.
len([],S,S):-!.
len([_|T],ST,S):-STN is ST+1,len(T,STN,S).
len([H|T],S):-len([H|T],0,S).

%Задание 10. Построить предикат, который переворачивает список.
poplast([H|[L]],[H],L):-!.
poplast([H|T],[H|NT],L):-poplast(T,NT,L).

reverse([H],[H]):-!.
reverse([H|T],[HN|TN]):-poplast([H|T],[HT|TT],HN), reverse([HT|TT],TN).
%Задание 11. Построить предикат p(Sublist,List), который возвращает true,
%если элементы Sublist встречается в List в том же порядке.
p([],_):-!.
p(ST,[H|T]):-(SH=:=H)->(p(ST,T));(p(ST,T)).
